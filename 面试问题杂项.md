# 面试问题杂项

[TOC]

### 大数据问题

大事实上，针对典型的Top k问题，采取的对策一般都是“分而治之/散列映射（如有必要）+ hash_map+堆”。[注：hash取模是一种等价映射，不会存在同一个IP分散到不同的小文件中的情况。换言之，如果两个IP相等，那么经过hash(IP)之后的散列值是相同的，将此散列值取模（如模1000）必定仍然相等，所以同一个IP在散列取模后，只可能落在同一个小文件中，不可能被分散]。

## C++ STL 容器

因为set、map、multiset和multimap的实现都是基于红黑树的，所以有自动排序功能，而hash_set、hash_map、hash_multiset和hash_multimap的实现都是基于hashtable的，所以不含有自动排序功能，加个前缀multi_无非就是允许键重复而已。

## Buffer与Cache的区别

1. buffer和cache都是内存中的一块区域，当CPU需要写数据到磁盘时，由于磁盘速度比较慢，所以CPU先把数据存进buffer，然后CPU去执行其他任务，buffer中的数据会定期写入磁盘；

2. 当CPU需要从磁盘读入数据时，由于磁盘速度比较慢，可以把即将用到的数据提前存入cache，CPU直接从Cache中拿数据要快的多。

   

## Simhash网页重复检测

simhash作为局部敏感散列（locality sensitive hash）的一种，其主要思想是降维，将高维的特征向量映射成低维的特征向量，通过两个向量的汉明距离来判定文章是否重复或者高度近似。在信息论中，两个等长字符串之间的汉明距离是两个字符串对应位置的不同字符的个数。也就是说，它就是将一个字符串变换成另外一个字符串需要替换的字符个数。求解二进制的异或操作

### 倒排索引（inverted index）关键字搜索

倒排索引是一种索引方法，用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射，常用于搜索引擎和关键字查询等问题中。



## Trie树

也即字典树，又称单词查找树或键树，是一种树形结构，常用于统计和排序大量字符串等场景中（但不仅限于字符串），且经常被搜索引擎用于文本词频统计。它的优点是最大限度地减少无谓的字符串比较，查询效率比较高。
Trie树的核心思想是以空间换时间，利用字符串的公共前缀来降低查询时间的开销，以达到提高效率的目的。

它有以下三个基本性质。

1. 根结点不包含字符，除根结点外每一个结点都只包含一个字符。
2. 从根结点到某一结点的路径上经过的字符连接起来，即为该结点对应的字符串。
3. 每个结点的所有子结点包含的字符都不相同。

![img](https://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase64152782097177772247.png)

## 垃圾邮件过滤

1. 利用布隆过滤器解决存储问题
2. 利用贝叶斯分裂鉴别一份邮件是否为垃圾邮件，从而减少误判率

### 布隆过滤器(Bloom Filter)

布隆过滤器是一种空间效率很高的随机数据结构，它可以看成是对位图的扩展。其结构是长度为n（如何计算最优n，后面会给出）的位数组，初始化为全0。当一个元素被加入集合中时，通过k个散列函数将这个元素映射成一个位数组中的k个点，并将这k个点全部置为1。

在检索一个元素是否在一个集合中时，我们只要看看这个元素被映射成位阵列的k个点是不是都是1，就能大致判断出集合中有没有那个元素：如果这k个点中有任何一个点为0，则被检索元素在集合中一定不存在；如果这k个点都是1，则被检索元素很可能在集合中。

但是，布隆过滤器也有它的缺点或不足，即它有一定的误判率——在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误判为属于这个集合。因此，它不适合那些“零误判”的应用场合。而在能容忍低误判率的应用场合下，布隆过滤器通过极少的误判换取了存储空间的极大节省。

## 位图

所谓位图，就是用一个位（bit）来标记某个元素对应的值，而键就是该元素。由于采用了位为单位来存储数据，因此可以大大节省存储空间。

位图的方案针对大数据的排序前提是不包含重复的数据，有则该方案不适用

## Mapreduce

Mapreduce是一种计算模型，简单地说就是将大批量的工作或者数据分解执行，称之为Map，　然后再将结果合并成最终结果，称之为Reduce

可以说，Mapreduce的原理就是一个归并排序，它的适用范围为数据量大二数据种类少以致可以放入内存的场景，Mapreduce模式的主要思想是将要执行的问题（如程序），自动拆分成Map和Reduce的方式。流程图如下：

![img](https://julyedu-img.oss-cn-beijing.aliyuncs.com/quesbase64152767715390493817.png)

MapReduce 借鉴了函数式程序设计语言的设计思想，其软件实现是指定一个Map函数，把键值对映射成新的键值对，形成一系列中间结果构成的键值对，然后把它们传给 Reduce 函数，把具有相同中间形式的键值对合并在一起。Map 函数和Reduce函数具有一定的关联性。

## 设计读写速度高的系统

涉及到BigTable的模型。主要思想是将随机写转化为顺序写，进而大大提高写速度。具体是：由于磁盘物理结构的独特设计，其并发的随机写（主要是因为磁盘寻道时间长）非常慢，考虑到这一点，在BigTable模型中，首先会将并发写的大批数据放到一个内存表（称为“memtable”）中，当该表大到一定程度后，会顺序写到一个磁盘表（称为“SSTable”）中，这种写是顺序写，效率极高。

随机读可不可以这样优化？答案是：看情况。通常而言，如果读并发度不高，则不可以这么做，因为如果将多个读重新排列组合后再执行，系统的响应时间太慢，用户可能接受不了，而如果读并发度极高，也许可以采用类似机制。

##　非高并发服务器设计

凡是不涉及高并发的，基本可以采用google的三个技术解决，分别为：GFS，MapReduce，Bigtable，这三个技术被称为“google三驾马车”，

## Thrift

Thrift是一个跨语言的RPC框架，分别解释一下“RPC”和“跨语言”，RPC是远程过程调用，其使用方式与调用一个普通函数一样，但执行体发生在远程机器上。跨语言是指不同语言之间进行通信，比如c/s架构中，server端采用C++编写，client端采用PHP编写，怎样让两者之间通信，thrift是一种很好的方式。